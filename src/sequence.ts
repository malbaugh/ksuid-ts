import { KSUID } from './ksuid';

/**
 * Sequence is a KSUID generator which produces a sequence of ordered KSUIDs
 * from a seed. Up to 65536 KSUIDs can be generated for a single seed.
 */
export class Sequence {
  /**
   * The seed KSUID is used as base for the generator
   * All generated KSUIDs share the same leading 18 bytes of the seed
   */
  public seed: KSUID;
  
  /**
   * Counter for generating sequential IDs
   * Only 2 bytes are used (uint16), but we use number for overflow detection
   */
  private count: number = 0;
  
  constructor(options: { seed?: KSUID } = {}) {
    this.seed = options.seed || KSUID.new();
  }
  
  /**
   * Produces the next KSUID in the sequence
   * @returns The next KSUID or throws an error if the sequence is exhausted
   */
  public next(): KSUID {
    if (this.count >= 0xFFFF) {
      throw new Error('Too many IDs were generated');
    }
    
    const id = this.generateWithSequenceNumber(this.count);
    this.count++;
    
    return id;
  }
  
  /**
   * Returns the inclusive min and max bounds of the KSUIDs that may be generated by the sequence
   * If all ids have been generated already then the returned min value is equal to the max
   */
  public bounds(): { min: KSUID, max: KSUID } {
    const count = this.count > 0xFFFF ? 0xFFFF : this.count;
    
    // If count is 0, min and max are based on 0 and 0xFFFF
    // Otherwise, min is based on the last generated count - 1
    const minCount = count === 0 ? 0 : count - 1;
    
    return {
      min: this.generateWithSequenceNumber(minCount),
      max: this.generateWithSequenceNumber(0xFFFF)
    };
  }
  
  /**
   * Generates a KSUID with a specific sequence number
   */
  private generateWithSequenceNumber(n: number): KSUID {
    // Get a copy of the seed bytes
    const bytes = this.seed.getBytes();
    
    // Set the sequence number in the last 2 bytes
    bytes[bytes.length - 2] = (n >> 8) & 0xFF;
    bytes[bytes.length - 1] = n & 0xFF;
    
    return new KSUID(bytes);
  }
} 